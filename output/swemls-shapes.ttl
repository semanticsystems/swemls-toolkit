@prefix :       <https://w3id.org/semsys/ns/swemls#> .
@prefix opmw:   <http://www.opmw.org/ontology/> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix p-plan: <http://purl.org/net/p-plan#> .
@prefix rdf:    <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:   <http://www.w3.org/2000/01/rdf-schema#> .
@prefix res:    <http://semantic-systems.net/swemls/> .
@prefix sh:     <http://www.w3.org/ns/shacl#> .
@prefix skos:   <http://www.w3.org/2004/02/skos/core#> .
@prefix terms:  <http://purl.org/dc/terms/> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix xml:    <http://www.w3.org/XML/1998/namespace> .
@prefix xsd:    <http://www.w3.org/2001/XMLSchema#> .

res:Pattern.A2.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern A2" ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "A2 must have exactly one data I/O" ;
                       sh:minCount  1 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "A2 must have exactly one ML steps/components" ;
                       sh:minCount  1 ;
                       sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "A2.ML1 component must have exactly one input of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "A2.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A2 .\n\t\t\t}\n\t\t"
                     ] .

:Pattern.I3.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I3.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.I3.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I3 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T7.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T7" ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T7 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T22  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T22" ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T22 must have exactly 3 data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T22 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T22.ML3 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T22.ML3 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "T22.ML2 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T22.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T22.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T22.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T22 must have exactly 3 ML steps/components" ;
                        sh:minCount  3 ;
                        sh:path      :hasStepML
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T22 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.O4  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern O4" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "O1.ML1 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML1 component must have exactly 1 output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML4 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML4 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML4 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML5 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "O1.ML5 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML5 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "O1.ML3 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML3 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  5 ;
                        sh:message   "O1 must have exactly 5 ML steps/components" ;
                        sh:minCount  5 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  6 ;
                        sh:message   "O1 must have exactly 6 data I/O" ;
                        sh:minCount  6 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "O1 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O4 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.I6.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I6" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I6.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I6.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I6 must have exactly two data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I6 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I6.ML2 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I6.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I6 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I6 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.F2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.F2.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F2 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T6.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T6.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T6.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T6 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T10.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> { data/sym -> KR } -> sym]" ;
        sh:name       "Pattern T10" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T10.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T10.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T10 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  3 ;
                                       sh:message   "T10.KR1 component must have exactly three inputs" ;
                                       sh:minCount  3 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T10.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T10 must have exactly three symbol I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T10 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T10 must have exactly on ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T10 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.O1.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.O1.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.O1.ML2 ;\n\t\t\t\t\t\t:componentInput ?d3 ;\n\t\t\t\t\t\t:componentOutput ?d4, ?sw1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.O1.KR1 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?sw1, ?sw2;\n\t\t\t\t\t\t:componentOutput ?d5 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml2 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.O1.ML3 ;\n\t\t\t\t\t\t:componentInput ?d5;\n\t\t\t\t\t\t:componentOutput ?d6 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t\t?ml4 \t:hasCorrespondingPatternStep res:Pattern.O1.ML4 ;\n\t\t\t\t\t\t:componentInput ?d2, ?d4, ?d6;\n\t\t\t\t\t\t:componentOutput ?d7 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1, ?ml2, ?ml3 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasStepML4 ?ml4 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 ;\n\t\t\t\t\t\t:hasVariableData4 ?d4 ;\n\t\t\t\t\t\t:hasVariableData5 ?d5 ;\n\t\t\t\t\t\t:hasVariableData6 ?d6 ;\n\t\t\t\t\t\t:hasVariableData7 ?d7 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O1 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T16.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T16.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1, ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T16.ML2 ;\n\t\t\t\t\t\t:componentInput ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T16 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.A3.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.A3.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A3 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.Y4.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.Y4.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.Y4.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw3 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.Y4.ML3 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?sw2;\n\t\t\t\t\t\t:componentOutput ?sw4 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 , ?ml2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableSW4 ?sw4 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y4 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.I2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I2.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.I2.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I2 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.Y1.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[{ sym>ML>data / data>ML>data } -> ML -> sym]" ;
        sh:name       "Pattern Y1" ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y1.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y1.ML2 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y1.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y1.ML1 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "Y1 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "Y1 must have exactly 3 ML steps/components" ;
                        sh:minCount  3 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "Y1 must have exactly 3 data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "Y1.ML3 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y1.ML3 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y1 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T23.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T23.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T23.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T23 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.F1.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.F1.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F1 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.A1.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern A1" ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "A1 must have exactly two symbol I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "A1.ML1 component must have exactly one input of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "A1.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A1 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T12.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data/sym->KR->sym->ML->sym]" ;
        sh:name       "Pattern T12" ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T12 must have exactly three symbol I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T12 must have exactly on ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T12.KR1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T12.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T12 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T12.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T12.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T12 must have exactly one data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T12 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T23.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T23" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T23.ML1 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T23.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T23 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T23.ML2 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T23.ML2 component must have exactly 1 output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T23 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T23 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T23 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.I2.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I2" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I2.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I2.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I2.ML2 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I2.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I2 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I2 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I2 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T5.workflow.builder
        rdf:type     sh:NodeShape ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "T5 must have exactly one data I/O" ;
                       sh:minCount  1 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  3 ;
                       sh:message   "T5 must have exactly three symbol I/O" ;
                       sh:minCount  3 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "T5 must have exactly two ML steps/components" ;
                       sh:minCount  1 ;
                       sh:path      :hasStepKR
                     ] ;
        sh:property  [ sh:path      :hasStepML1 ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "T5.ML1 component must have exactly one input of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "T5.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:property  [ sh:path      :hasStepKR1 ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  2 ;
                                      sh:message   "T5.ML2 component must have exactly two inputs of type :Symbol" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "T5.ML2 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:rule      [ rdf:type      sh:SPARQLRule ;
                       sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T5.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T5.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                       sh:prefixes   res:prefixes
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T5 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.O1  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern O1" ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  3 ;
                                       sh:message   "O1.KR1 component must have exactly 3 inputs" ;
                                       sh:minCount  3 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.KR1 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  7 ;
                        sh:message   "O1 must have exactly 7 data I/O" ;
                        sh:minCount  7 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML3 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML3 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "O1 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML1 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML1 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "O1.ML2 component must have exactly 2 outputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML4 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  3 ;
                                       sh:message   "O1.ML4 component must have exactly 3 inputs of type :Data" ;
                                       sh:minCount  3 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O1.ML4 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  4 ;
                        sh:message   "O1 must have exactly 4 ML steps/components" ;
                        sh:minCount  4 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "O1 must have exactly 1 KR steps/components" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O1 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.F2.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern F2" ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "F2 must have exactly one data I/O" ;
                       sh:minCount  1 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "F2 must have exactly two symbol I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "F2.ML1 component must have exactly two inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "F2.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F2 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T2.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T2" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T2.ML1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T2.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T2.ML2 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T2.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T2 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T2 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T2 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T2 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T15.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T15" ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T15.KR1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T15.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T15 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T15 must have exactly one ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  4 ;
                        sh:message   "T15 must have exactly 4 symbol I/O" ;
                        sh:minCount  4 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  2 ;
                                       sh:message   "T15.ML1 component must have exactly 2 input of type :Symbol" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T15.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T15 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T15.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T15.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T15.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?sw3 ;\n\t\t\t\t\t\t:componentOutput ?sw4 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableSW4 ?sw4  .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T15 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.A2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.A2.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A2 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T5.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[{data -> ML -> sym/sym} -> KR -> sym]" ;
        sh:name       "Pattern T5" ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepKR1/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T5 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.I1.workflow.builder
        rdf:type     sh:NodeShape ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "I1 must have exactly one data I/O" ;
                       sh:minCount  1 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "I1 must have exactly two symbol I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "I1 must have exactly two ML steps/components" ;
                       sh:minCount  2 ;
                       sh:path      :hasStepML
                     ] ;
        sh:property  [ sh:path      :hasStepML1 ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "I1.ML1 component must have exactly one input of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "I1.ML1 component must have exactly one output of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:property  [ sh:path      :hasStepML2 ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "I1.ML2 component must have exactly one input of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "I1.ML2 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:rule      [ rdf:type      sh:SPARQLRule ;
                       sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I1.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.I1.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                       sh:prefixes   res:prefixes
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I1 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T18.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T18" ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T18 must have exactly 2 data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T18 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T18.ML1 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T18.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T18.ML2 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T18.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T18 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T18 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T12.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T12.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1, ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T12.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T12 .\n\t\t\t}\n\t\t"
                   ] .

<https://w3id.org/semsys/ns/swemls/Pattern.T3.shape>
        rdf:type      sh:NodeShape ;
        rdfs:comment  " [{sym -> ML -> data / data} -> ML -> sym]" ;
        sh:name       "Pattern T3" ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "T3.ML2 component must have exactly two inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T3.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T3.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T3.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T3 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T3 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T3 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  <https://w3id.org/semsys/ns/swemls/prefixes> ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  <https://w3id.org/semsys/ns/swemls/prefixes> ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T3 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.A3.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern A3" ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "A3.ML1 component must have exactly one input of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "A3.ML1 component must have exactly one output of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A3 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.I4.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I4" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I4 must have exactly one KR steps/components" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I4 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I4.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I4.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I4.KR1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I4.KR1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I4 must have exactly one data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML1/p-plan:isPreceededBy ?value1 ;\n                        :hasStepKR1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML1/:componentInput ?value1 ;\n                        :hasStepKR1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I4 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T22.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T22.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T22.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.T22.ML3 ;\n\t\t\t\t\t\t:componentInput ?d3;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T22 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T8.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T8" ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  2 ;
                                       sh:message   "T8.KR1 component must have exactly two inputs of type :Symbol" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T8.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T8 must have exactly on ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T8 must have exactly three symbol I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T8 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T8.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T8.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T8 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.I7.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I7.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.I7.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?d1 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I7 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.I7.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I7" ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I7 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I7.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I7.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I7 must have exactly two data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I7 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I7.ML2 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I7.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I7 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T4.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T4.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T4.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T4 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T14.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T14.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T14.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T14 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.O3  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern O3" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "O3 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "O3 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "O3 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "O3.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O3.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "O3.ML1 component must have exactly two input of type :Instance" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "O3.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O3 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.A1.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.A1.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.A1 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T11.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[sym / data -> ML -> sym / data -> KR -> data]" ;
        sh:name       "Pattern T11" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T11 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T11.ML1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T11.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T11 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T11 must have exactly on ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T11.KR1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T11.KR1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T11 must have exactly three data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T11 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.Y2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.Y2.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.Y2.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d3 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.Y2.ML3 ;\n\t\t\t\t\t\t:componentInput ?d2 , ?d3;\n\t\t\t\t\t\t:componentOutput ?d4 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 , ?ml2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 ;\n\t\t\t\t\t\t:hasVariableData4 ?d4 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y2 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T11.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T11.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1, ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T11.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T11 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T21.workflow.builder
        rdf:type     sh:NodeShape ;
        sh:property  [ sh:maxCount  3 ;
                       sh:message   "T20 must have exactly 3 symbol I/O" ;
                       sh:minCount  3 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "T20 must have exactly 1 data I/O" ;
                       sh:minCount  1 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "T20 must have exactly two ML steps/components" ;
                       sh:minCount  2 ;
                       sh:path      :hasStepML
                     ] ;
        sh:property  [ sh:path      :hasStepML1 ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "T20.ML1 component must have exactly 1 input of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "T20.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:property  [ sh:path      :hasStepML2 ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "T20.ML2 component must have exactly 2 inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "T20.ML2 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:rule      [ rdf:type      sh:SPARQLRule ;
                       sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T21.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T21.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                       sh:prefixes   res:prefixes
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T21 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T21.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T21" ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T21 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.I6.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I6.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.I6.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I6 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T3.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T3.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T3.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?d2 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   <https://w3id.org/semsys/ns/swemls/prefixes>
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  <https://w3id.org/semsys/ns/swemls/prefixes> ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T3 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T13.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T13" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T13 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T13 must have exactly one ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T13.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T13.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T13.KR1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T13.KR1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T13 must have exactly three data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T13 must have exactly one symbol I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T13 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.Y2  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern Y2" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y2.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y2.ML1 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  4 ;
                        sh:message   "Y2 must have exactly 4 data I/O" ;
                        sh:minCount  4 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "Y2 must have exactly 3 ML steps/components" ;
                        sh:minCount  3 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "Y2.ML3 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y2.ML3 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y2.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y2.ML2 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "Y2 must have exactly 1 symbol I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y2 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.I3.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I3" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I3 must have exactly one data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I3 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "I3 must have exactly one KR steps/components" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I3.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I3.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I3.KR1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I3.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I3 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T13.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T13.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1, ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T13.ML1 ;\n\t\t\t\t\t\t:componentInput ?d2 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T13 .\n\t\t\t}\n\t\t"
                   ] .

res:prefixes  rdf:type  owl:Ontology ;
        owl:imports  sh: ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "http://semantic-systems.net/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] .

res:Pattern.F3.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern F3" ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "F3 must have exactly two data I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "F3 must have exactly two symbol I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "F3.ML1 component must have exactly two inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "F3.ML1 component must have exactly two outputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F3 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T3.shape  rdf:type  sh:NodeShape ;
        sh:name         "SWeMLS validation constraints" ;
        sh:property     [ sh:message   "A SWeML system must have at least one symbol I/O" ;
                          sh:minCount  1 ;
                          sh:path      :hasSymbolIO
                        ] ;
        sh:property     [ sh:message   "A SWeML system must have at least one ML steps/components" ;
                          sh:minCount  1 ;
                          sh:path      :hasStepML
                        ] ;
        sh:targetClass  :System .

res:Pattern.T16.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T16" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T16.ML1 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T16.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T16 must have exactly three data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T16.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T16.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T16 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T16 must have exactly one symbol I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T16 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.Y1.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.Y1.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.Y1.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d3 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.Y1.ML3 ;\n\t\t\t\t\t\t:componentInput ?d2 , ?d3;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 , ?ml2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y1 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T9.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T9.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T9.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T9 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T10.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T10.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T10.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?sw2, ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T10 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.O4.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.O4.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1, ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.O4.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml3 \t:hasCorrespondingPatternStep res:Pattern.O4.ML3 ;\n\t\t\t\t\t\t:componentInput ?sw2, ?d2;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1, ?ml2 .\n\t\t\t\t?ml4 \t:hasCorrespondingPatternStep res:Pattern.O4.ML4 ;\n\t\t\t\t\t\t:componentInput ?d4;\n\t\t\t\t\t\t:componentOutput ?d5 .\n\t\t\t\t?ml5 \t:hasCorrespondingPatternStep res:Pattern.O4.ML5 ;\n\t\t\t\t\t\t:componentInput ?d3, ?d5;\n\t\t\t\t\t\t:componentOutput ?d6 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml3, ?ml4 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepML3 ?ml3 ;\n\t\t\t\t\t\t:hasStepML4 ?ml4 ;\n\t\t\t\t\t\t:hasStepML5 ?ml5 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 ;\n\t\t\t\t\t\t:hasVariableData4 ?d4 ;\n\t\t\t\t\t\t:hasVariableData5 ?d5 ;\n\t\t\t\t\t\t:hasVariableData6 ?d6 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O4 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T19.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T19.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T19.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?sw3 ;\n\t\t\t\t\t\t:componentOutput ?sw4 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableSW4 ?sw4 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T19 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T20.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T20.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T20.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T20 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T6.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T6" ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T6 must have exactly three data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T6.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T6.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T6 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T6 must have exactly one symbol I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T6.ML2 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T6.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T6 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T19.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T19" ;
        sh:property   [ sh:maxCount  4 ;
                        sh:message   "T19 must have exactly 4 symbol I/O" ;
                        sh:minCount  4 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T19 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T19.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T19.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  2 ;
                                       sh:message   "T19.ML2 component must have exactly 2 inputs of type :Symbol" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T19.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T19 .\n\t\t\t}\n\t\t"
                      ] .

<https://w3id.org/semsys/ns/swemls/prefixes>
        rdf:type     owl:Ontology ;
        owl:imports  sh: ;
        sh:declare   [ sh:namespace  "http://purl.org/net/p-plan#"^^xsd:anyURI ;
                       sh:prefix     "p-plan"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/p-plan-extension#"^^xsd:anyURI ;
                       sh:prefix     "ex"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls/"^^xsd:anyURI ;
                       sh:prefix     "res"
                     ] ;
        sh:declare   [ sh:namespace  "https://w3id.org/semsys/ns/swemls#"^^xsd:anyURI ;
                       sh:prefix     ""
                     ] .

:Pattern.I5.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I5.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.I5.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I5 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.I5.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern I5" ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I5 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I5.ML2 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I5.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "I5.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "I5.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "I5 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I5 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T9.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[sym -> ML -> sym/data -> KR -> data]" ;
        sh:name       "Pattern T9" ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T9.KR1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T9.KR1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T9 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T9.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T9.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T9 must have exactly on ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T9 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T9 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of previous step: ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepKR1/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T9 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T2.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T2.ML2 ;\n\t\t\t\t\t\t:componentInput ?d2 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T2 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.F4.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.F4.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentInput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?sw3 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F4 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.Y4  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern Y4" ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y4.ML2 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y4.ML2 component must have exactly 1 output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  4 ;
                        sh:message   "Y4 must have exactly 4 symbol I/O" ;
                        sh:minCount  4 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML3 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "Y4.ML3 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y4.ML3 component must have exactly 1 output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y4.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "Y4.ML1 component must have exactly 1 output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "Y4 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "Y4 must have exactly 3 ML steps/components" ;
                        sh:minCount  3 ;
                        sh:path      :hasStepML
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.Y4 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T20.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T20" ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T20 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T20 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T20.ML1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T20.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T20.ML2 component must have exactly 2 inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T20.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T20 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T8.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T8.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T8.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw2 , ?sw3 ;\n\t\t\t\t\t\t:componentOutput ?sw4 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableSW4 ?sw4 ;\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T8 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.O3.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.O3.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 , ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.O3.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?d1 ;\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O3 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.T18.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T18.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1, ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T18.ML2 ;\n\t\t\t\t\t\t:componentInput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?d2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T18 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.I4.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.I4.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?kr1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.I4.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I4 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.O2  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern O2" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "O2.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "O2.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "O2 must have exactly 1 KR steps/components" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "O2 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "O2 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "O2.KR1 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "O2.KR1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "O2 must have exactly 1 ML steps/components" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O2 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T1.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T1.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T1.ML2 ;\n\t\t\t\t\t\t:componentInput ?d2 , ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T1 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.I1.shape  rdf:type  sh:NodeShape ;
        sh:name    "Pattern I1" ;
        sh:sparql  [ rdf:type     sh:SPARQLConstraint ;
                     sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                   ] ;
        sh:sparql  [ rdf:type     sh:SPARQLConstraint ;
                     sh:message   "output from step ML1 ('{?value1}') should be used as input value of step ML2" ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/:componentInput ?value1 ;\n                        :hasStepML1/:componentOutput ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.I1 .\n\t\t\t}\n\t\t"
                   ] .

:Pattern.F3.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.F3.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F3 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.F1.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern F1" ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "F1 must have exactly two data I/O" ;
                       sh:minCount  2 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "F1.ML1 component must have exactly two inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "F1.ML1 component must have exactly one output of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F1 .\n\t\t\t}\n\t\t"
                     ] .

res:Pattern.T1.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[{data -> ML -> data / sym} -> ML -> sym]" ;
        sh:name       "Pattern T1" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T1.ML1 component must have exactly one input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T1.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Instance ;
                                       sh:maxCount  2 ;
                                       sh:message   "T1.ML2 component must have exactly two inputs" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T1.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T1 must have exactly two data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T1 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T1 must have exactly two symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T1 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T14.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T14" ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T14 must have exactly 2 data I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:path      :hasStepKR1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T14.KR1 component must have exactly 1 input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T14.KR1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T14 must have exactly 2 symbol I/O" ;
                        sh:minCount  2 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "T14.ML1 component must have exactly 2 inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T14.ML1 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T14 must have exactly one KR component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepKR
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T14 must have exactly one ML step/component" ;
                        sh:minCount  1 ;
                        sh:path      :hasStepML
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T14 .\n\t\t\t}\n\t\t"
                      ] .

:Pattern.T7.workflow.builder
        rdf:type     sh:NodeShape ;
        sh:property  [ sh:maxCount  3 ;
                       sh:message   "T7 must have exactly three data I/O" ;
                       sh:minCount  3 ;
                       sh:path      :hasDataIO
                     ] ;
        sh:property  [ sh:maxCount  4 ;
                       sh:message   "T7 must have exactly four symbol I/O" ;
                       sh:minCount  4 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:maxCount  2 ;
                       sh:message   "T7 must have exactly two ML steps/components" ;
                       sh:minCount  2 ;
                       sh:path      :hasStepML
                     ] ;
        sh:property  [ sh:maxCount  1 ;
                       sh:message   "T7 must have exactly one KR steps/components" ;
                       sh:minCount  1 ;
                       sh:path      :hasStepKR
                     ] ;
        sh:property  [ sh:path      :hasStepML1 ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "T7.ML1 component must have exactly two inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Data ;
                                      sh:maxCount  1 ;
                                      sh:message   "T7.ML1 component must have exactly one output of type :Data" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:property  [ sh:path      :hasStepML2 ;
                       sh:property  [ sh:class     :Instance ;
                                      sh:maxCount  2 ;
                                      sh:message   "T7.ML2 component must have exactly two inputs" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "T7.ML2 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ] ;
                       sh:property  [ sh:path      :hasStepKR1 ;
                                      sh:property  [ sh:class     :Symbol ;
                                                     sh:maxCount  2 ;
                                                     sh:message   "T7.KR1 component must have exactly two inputs of type :Symbol" ;
                                                     sh:minCount  2 ;
                                                     sh:path      :componentInput
                                                   ] ;
                                      sh:property  [ sh:class     :Data ;
                                                     sh:maxCount  1 ;
                                                     sh:message   "T7.KR1 component must have exactly one output of type :Data" ;
                                                     sh:minCount  1 ;
                                                     sh:path      :componentOutput
                                                   ]
                                    ]
                     ] ;
        sh:rule      [ rdf:type      sh:SPARQLRule ;
                       sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T7.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?sw1 ;\n\t\t\t\t\t\t:componentOutput ?d2 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T7.ML2 ;\n\t\t\t\t\t\t:componentInput ?d2 , ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?sw3  ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.T7.KR1 ;\n\t\t\t\t\t\t:componentInput ?sw3 , ?sw4 ;\n\t\t\t\t\t\t:componentOutput ?d3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml2 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableSW4 ?sw4 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 ;\n\t\t\t\t\t\t:hasVariableData2 ?d2 ;\n\t\t\t\t\t\t:hasVariableData3 ?d3 .\n\t\t\t}\n\t\t" ;
                       sh:prefixes   res:prefixes
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T7 .\n\t\t\t}\n\t\t"
                     ] .

:Pattern.O2.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.O2.ML1 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw2 .\n\t\t\t\t?kr1 \t:hasCorrespondingPatternStep res:Pattern.O2.KR1 ;\n\t\t\t\t\t\t:componentInput ?d1 , ?sw1;\n\t\t\t\t\t\t:componentOutput ?sw2 ;\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepKR1 ?kr1 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.O2 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.F4.shape  rdf:type  sh:NodeShape ;
        sh:name      "Pattern F4" ;
        sh:property  [ sh:maxCount  3 ;
                       sh:message   "F4 must have exactly three symbol I/O" ;
                       sh:minCount  3 ;
                       sh:path      :hasSymbolIO
                     ] ;
        sh:property  [ sh:path      :hasStepML ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  2 ;
                                      sh:message   "F4.ML1 component must have exactly two inputs of type :Symbol" ;
                                      sh:minCount  2 ;
                                      sh:path      :componentInput
                                    ] ;
                       sh:property  [ sh:class     :Symbol ;
                                      sh:maxCount  1 ;
                                      sh:message   "F4.ML1 component must have exactly one output of type :Symbol" ;
                                      sh:minCount  1 ;
                                      sh:path      :componentOutput
                                    ]
                     ] ;
        sh:target    [ rdf:type     sh:SPARQLTarget ;
                       sh:prefixes  res:prefixes ;
                       sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.F4 .\n\t\t\t}\n\t\t"
                     ] .

:Pattern.T17.workflow.builder
        rdf:type   sh:NodeShape ;
        sh:rule    [ rdf:type      sh:SPARQLRule ;
                     sh:construct  "\n\t\t\tCONSTRUCT {\n\t\t\t\t?ml1 \t:hasCorrespondingPatternStep res:Pattern.T17.ML1 ;\n\t\t\t\t\t\t:componentInput ?sw1, ?sw2 ;\n\t\t\t\t\t\t:componentOutput ?d1 .\n\t\t\t\t?ml2 \t:hasCorrespondingPatternStep res:Pattern.T17.ML2 ;\n\t\t\t\t\t\t:componentInput ?d1 ;\n\t\t\t\t\t\t:componentOutput ?sw3 ;\n\t\t\t\t\t\tp-plan:isPreceededBy ?ml1 .\n\t\t\t}\n\t\t\tWHERE {\n\t\t\t\t$this \t:hasStepML1 ?ml1 ;\n\t\t\t\t\t\t:hasStepML2 ?ml2 ;\n\t\t\t\t\t\t:hasVariableSW1 ?sw1 ;\n\t\t\t\t\t\t:hasVariableSW2 ?sw2 ;\n\t\t\t\t\t\t:hasVariableSW3 ?sw3 ;\n\t\t\t\t\t\t:hasVariableData1 ?d1 .\n\t\t\t}\n\t\t" ;
                     sh:prefixes   res:prefixes
                   ] ;
        sh:target  [ rdf:type     sh:SPARQLTarget ;
                     sh:prefixes  res:prefixes ;
                     sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T17 .\n\t\t\t}\n\t\t"
                   ] .

res:Pattern.T4.shape  rdf:type  sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T4" ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T4 must have exactly three data I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T4 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T4.ML1 component must have exactly one input of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T4.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  2 ;
                                       sh:message   "T4.ML2 component must have exactly two inputs of type :Data" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T4.ML2 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T4 .\n\t\t\t}\n\t\t"
                      ] .

res:Pattern.T17.shape
        rdf:type      sh:NodeShape ;
        rdfs:comment  "[data -> ML -> sym -> ML -> data]" ;
        sh:name       "Pattern T17" ;
        sh:property   [ sh:path      :hasStepML1 ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  2 ;
                                       sh:message   "T17.ML1 component must have exactly 2 inputs of type :Symbol" ;
                                       sh:minCount  2 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T17.ML1 component must have exactly one output of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:path      :hasStepML2 ;
                        sh:property  [ sh:class     :Data ;
                                       sh:maxCount  1 ;
                                       sh:message   "T17.ML2 component must have exactly 1 input of type :Data" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentInput
                                     ] ;
                        sh:property  [ sh:class     :Symbol ;
                                       sh:maxCount  1 ;
                                       sh:message   "T17.ML2 component must have exactly one output of type :Symbol" ;
                                       sh:minCount  1 ;
                                       sh:path      :componentOutput
                                     ]
                      ] ;
        sh:property   [ sh:maxCount  3 ;
                        sh:message   "T17 must have exactly 3 symbol I/O" ;
                        sh:minCount  3 ;
                        sh:path      :hasSymbolIO
                      ] ;
        sh:property   [ sh:maxCount  2 ;
                        sh:message   "T17 must have exactly two ML steps/components" ;
                        sh:minCount  2 ;
                        sh:path      :hasStepML
                      ] ;
        sh:property   [ sh:maxCount  1 ;
                        sh:message   "T17 must have exactly 1 data I/O" ;
                        sh:minCount  1 ;
                        sh:path      :hasDataIO
                      ] ;
        sh:sparql     [ rdf:type     sh:SPARQLConstraint ;
                        sh:message   "isPreceededBy value ('{?value1}') is not the same as the value of hasStepML1 ('?value2')" ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n            SELECT $this $value1 $value2\n            WHERE {\n                $this   :hasStepML2/p-plan:isPreceededBy ?value1 ;\n                        :hasStepML1 ?value2 .\n                FILTER (?value1 != ?value2 )\n            }\n            "
                      ] ;
        sh:target     [ rdf:type     sh:SPARQLTarget ;
                        sh:prefixes  res:prefixes ;
                        sh:select    "\n\t\t\tselect $this \n\t\t\twhere {\n\t\t\t\t$this a :System ; :hasCorrespondingPattern res:Pattern.T17 .\n\t\t\t}\n\t\t"
                      ] .
